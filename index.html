<!DOCTYPE html>
<html>
    <head>
        <title>HTML DOCUMENT</title>
    </head>
    <body>
        <h1>SRILATHA VUNNAM</h1>
        <p>MOUNIKA is my best friend.We both like rock and roll.</p>
    </body>

    <h1>Goa</h1>
<p>Goa is one of the most <b>favorite destination</b> among Indian tourists due to its pristine beaches. Dotted with hundreds of impressive beaches in Goa, the <b>incredible coastline</b> of more than 100 km offers beautiful views and serenity where tourists enjoy and relax in the Sun.</p>
<hr>
<h3>Directions to Goa from Maryville</h3>
<ol>
    <li> Maryville</li>
    <li>Dallas</li>
        <ol>
            <li>Dallas Airport</li>
            <li>Terminal></li>
            <li>Goa flight</li>
        </ol>

</ol>
<ul>
     <li>CheckinBag</li>
     <ul>
         <li>SafetyJacket</li>
         <li>Flora&TropicalSwimSuits</li>
         <li>CokarShort</li>
         <li>DigitalCamera</li>

     </ul>
</ul>

<a href="aboutme.html">Quick link to aboutme</a>





<hr>
<h3>Table</h3>
<p>Here are my favourite Non-veg items & drinks that I recommend</p>
<table>

    <tr>
        <th>Food&Drinks</th>
        <th>Location</th>
        <th>Cost</th>
    </tr>
    <tr>
        <td>Mutton fry</td>
        <td>Miriyala</td>
        <td>$30</td>
    </tr>
    <tr>
        <td>Beef</td>
        <td>Hyvee</td>
        <td>$15</td>
    </tr>
    <tr>
        <td>Pork</td>
        <td>Walmart</td>
        <td>$20</td>
    </tr>
    <tr>
        <td>ThumbsUp</td>
        <td>finishLine</td>
        <td>$2</td>

    </tr>
</table>



<hr>
<h3>Dynamic programming </h3>
<blockquote>Dynamic programming is both a mathematical optimization method and a computer programming method. The method was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics.</blockquote>
<a href="https://en.wikipedia.org/wiki/Dynamic_programming"> quick-link to the source</a>
<pre>int m, n;
    vector<long long> dp_before(n), dp_cur(n);
    
    long long C(int i, int j);
    
    // compute dp_cur[l], ... dp_cur[r] (inclusive)
    void compute(int l, int r, int optl, int optr) {
        if (l > r)
            return;
    
        int mid = (l + r) >> 1;
        pair<long long, int> best = {LLONG_MAX, -1};
    
        for (int k = optl; k <= min(mid, optr); k++) {
            best = min(best, {(k ? dp_before[k - 1] : 0) + C(k, mid), k});
        }
    
        dp_cur[mid] = best.first;
        int opt = best.second;
    
        compute(l, mid - 1, optl, opt);
        compute(mid + 1, r, opt, optr);
    }
    
    int solve() {
        for (int i = 0; i < n; i++)
            dp_before[i] = C(0, i);
    
        for (int i = 1; i < m; i++) {
            compute(0, n - 1, 0, n - 1);
            dp_before = dp_cur;
        }
    
        return dp_before[n - 1];
    }



</pre>
<a href="p-algorithms.com/dynamic_programming/divide-and-conquer-dp.html">quick link to the source</a>


</table>





</html>






